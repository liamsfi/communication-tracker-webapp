<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Communication Tracker WebApp</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      line-height: 1.5;
    }
    h1 {
      color: #2f5496;
    }
    form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    label {
      font-weight: bold;
    }
    input, select, textarea {
      width: 100%;
      padding: 6px;
      box-sizing: border-box;
    }
    textarea {
      resize: vertical;
      height: 60px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: #d9e1f2;
    }
    tr:nth-child(even) {
      /* Stripe table rows for better readability */
      background-color: #f7f7f7;
    }
    /* Styling for the interactive grouped UI */
    .latest-row {
      background-color: #eaf2fb;
      cursor: pointer;
    }
    .details-row {
      background-color: #f7f9fc;
    }
    .toggle-icon {
      cursor: pointer;
      margin-right: 6px;
    }
    .nested-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    .nested-table th, .nested-table td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    .nested-table th {
      background-color: #f0f5ff;
    }
    .button-row {
      margin-top: 10px;
    }
    button {
      padding: 8px 14px;
      margin-right: 10px;
      border: none;
      background-color: #2f5496;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #274778;
    }

    /* Style for the paste area used for bulk Excel import */
    .paste-area {
      border: 2px dashed #a6b8d0;
      padding: 10px;
      min-height: 60px;
      margin-top: 10px;
      background-color: #f9fbff;
    }
  </style>
</head>
<body>
  <h1>Communication Tracker</h1>
  <p>
    This lightweight web app allows you to maintain a structured log of your
    communication updates. Use the form below to add new entries. Your data is
    saved in your browser's local storage so it persists across sessions on the
    same computer.
  </p>

  <form id="entryForm">
    <div>
      <label for="date">Date</label>
      <input type="date" id="date" required />
    </div>
    <div>
      <label for="person">Person</label>
      <!-- Dropdown for selecting a person -->
      <select id="person" required></select>
    </div>
    <!-- Container for adding a new person; hidden unless user selects "Add new person…" -->
    <div id="newPersonContainer" style="display: none;">
      <label for="newPerson">New Person</label>
      <input type="text" id="newPerson" placeholder="Enter new person's name" />
    </div>
    <div>
      <label for="category">Category</label>
      <select id="category" required>
        <option value="RFQ">RFQ</option>
        <option value="Quote">Quote</option>
        <option value="PO">PO</option>
        <option value="ETA">ETA</option>
        <option value="Meeting">Meeting</option>
        <option value="Claim">Claim</option>
        <option value="Payment">Payment</option>
        <option value="Other">Other</option>
      </select>
    </div>
    <div>
      <label for="reference">Reference/Item</label>
      <input type="text" id="reference" placeholder="e.g., SP25051301_C" required />
    </div>
    <div>
      <label for="description">Description / Update</label>
      <textarea id="description" required></textarea>
    </div>
    <div>
      <label for="nextSteps">Next Steps / Action</label>
      <textarea id="nextSteps" required></textarea>
    </div>
    <div class="button-row">
      <button type="submit">Add Entry</button>
      <button type="button" id="exportBtn">Export JSON</button>
      <button type="button" id="importBtn">Import JSON</button>
      <input type="file" id="fileInput" accept="application/json" style="display: none;" />
    </div>
  </form>

  <!-- Bulk import section -->
  <h2>Bulk Import from Excel</h2>
  <p>
    Copy rows from your Excel spreadsheet containing columns in the order: Date, Person, Category,
    Reference/Item, Description/Update, Next Steps/Action. Then click inside the area below and
    paste your table (Ctrl+V or Command+V). The table will appear with its formatting, and the
    data will be added to the log automatically. Header rows (with column names) are skipped.
  </p>
  <div id="pasteArea" class="paste-area" contenteditable="true"></div>

  <table id="logTable">
    <thead>
      <tr>
        <th>Date</th>
        <th>Person</th>
        <th>Category</th>
        <th>Reference/Item</th>
        <th>Description / Update</th>
        <th>Next Steps / Action</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    // Initialize or load existing log from localStorage
    let commLog = [];

    // Manage list of people for the person dropdown
    let persons = [];
    function loadPersons() {
      const data = localStorage.getItem('persons');
      if (data) {
        try {
          persons = JSON.parse(data);
        } catch (e) {
          persons = [];
        }
      }
      // If no persons stored or list is empty, use default names
      if (!Array.isArray(persons) || persons.length === 0) {
        persons = ['LG', 'MJ', 'TW', 'JY'];
      }
      renderPersonOptions();
    }
    function savePersons() {
      localStorage.setItem('persons', JSON.stringify(persons));
    }
    function renderPersonOptions() {
      const select = document.getElementById('person');
      if (!select) return;
      const current = select.value;
      select.innerHTML = '';
      persons.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p;
        opt.textContent = p;
        select.appendChild(opt);
      });
      // Add option to allow user to add a new person
      const otherOpt = document.createElement('option');
      otherOpt.value = '__other__';
      otherOpt.textContent = 'Add new person…';
      select.appendChild(otherOpt);
      // Restore selection if it still exists in the list
      if (current && persons.includes(current)) {
        select.value = current;
      } else {
        select.value = '';
      }
    }

    function loadLog() {
      const data = localStorage.getItem('comm_log');
      if (data) {
        try {
          commLog = JSON.parse(data);
        } catch (e) {
          console.error('Failed to parse log from localStorage', e);
          commLog = [];
        }
      } else {
        commLog = [];
      }
      renderTable();
    }

    function saveLog() {
      localStorage.setItem('comm_log', JSON.stringify(commLog));
    }

    function renderTable() {
      const tbody = document.querySelector('#logTable tbody');
      tbody.innerHTML = '';
      // Group entries by their reference/item so related updates appear together
      const groups = {};
      commLog.forEach(entry => {
        const ref = entry.reference || '';
        if (!groups[ref]) {
          groups[ref] = [];
        }
        groups[ref].push(entry);
      });
      // Sort groups by the date of their latest entry (descending)
      const sortedGroups = Object.entries(groups).sort((a, b) => {
        const aLatest = a[1].slice().sort((x, y) => new Date(y.date) - new Date(x.date))[0];
        const bLatest = b[1].slice().sort((x, y) => new Date(y.date) - new Date(x.date))[0];
        return new Date(bLatest.date) - new Date(aLatest.date);
      });
      sortedGroups.forEach(([ref, entries]) => {
        // Sort each group’s entries by date descending so the most recent comes first
        const sortedEntries = entries.slice().sort((a, b) => new Date(b.date) - new Date(a.date));
        const latest = sortedEntries[0];
        const previous = sortedEntries.slice(1);
        // Create the row that always shows the most recent update
        const trLatest = document.createElement('tr');
        trLatest.classList.add('latest-row');
        trLatest.innerHTML = `
          <td><span class="toggle-icon">${previous.length ? '&#9654;' : ''}</span>${latest.date}</td>
          <td>${latest.person}</td>
          <td>${latest.category}</td>
          <td>${latest.reference}</td>
          <td>${latest.description}</td>
          <td>${latest.nextSteps}</td>
        `;
        tbody.appendChild(trLatest);
        // If there are older updates, create a hidden row to display them
        if (previous.length) {
          const trDetail = document.createElement('tr');
          trDetail.classList.add('details-row');
          trDetail.style.display = 'none';
          const td = document.createElement('td');
          td.colSpan = 6;
          let nestedHtml = '<table class="nested-table"><thead><tr><th>Date</th><th>Person</th><th>Category</th><th>Reference/Item</th><th>Description / Update</th><th>Next Steps / Action</th></tr></thead><tbody>';
          previous.forEach(ent => {
            nestedHtml += `<tr><td>${ent.date}</td><td>${ent.person}</td><td>${ent.category}</td><td>${ent.reference}</td><td>${ent.description}</td><td>${ent.nextSteps}</td></tr>`;
          });
          nestedHtml += '</tbody></table>';
          td.innerHTML = nestedHtml;
          trDetail.appendChild(td);
          tbody.appendChild(trDetail);
          // Toggle the details row when the latest row is clicked
          trLatest.addEventListener('click', function (e) {
            // Prevent toggling when clicking inside the nested table
            if (e.target.closest('.nested-table')) return;
            if (trDetail.style.display === 'none') {
              trDetail.style.display = '';
              const iconSpan = trLatest.querySelector('.toggle-icon');
              if (iconSpan) iconSpan.innerHTML = '&#9660;';
            } else {
              trDetail.style.display = 'none';
              const iconSpan = trLatest.querySelector('.toggle-icon');
              if (iconSpan) iconSpan.innerHTML = '&#9654;';
            }
          });
        }
      });
    }

    document.getElementById('entryForm').addEventListener('submit', function (e) {
      e.preventDefault();
      // Determine the person: existing from dropdown or newly entered
      const personSelect = document.getElementById('person');
      let personVal = personSelect.value;
      if (personVal === '__other__') {
        personVal = document.getElementById('newPerson').value.trim();
        // If a new name was entered, add it to the list and persist
        if (personVal) {
          if (!persons.includes(personVal)) {
            persons.push(personVal);
            savePersons();
          }
        }
      }
      const entry = {
        date: document.getElementById('date').value,
        person: personVal,
        category: document.getElementById('category').value,
        reference: document.getElementById('reference').value.trim(),
        description: document.getElementById('description').value.trim(),
        nextSteps: document.getElementById('nextSteps').value.trim(),
      };
      commLog.push(entry);
      saveLog();
      renderTable();
      this.reset();
      // Hide new person input and reset its required attribute
      const newPersonContainer = document.getElementById('newPersonContainer');
      const newPersonInput = document.getElementById('newPerson');
      if (newPersonContainer) newPersonContainer.style.display = 'none';
      if (newPersonInput) newPersonInput.required = false;
      // Re-render person options in case a new one was added
      renderPersonOptions();
    });

    // Export log as JSON file
    document.getElementById('exportBtn').addEventListener('click', function () {
      const dataStr = JSON.stringify(commLog, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'communication_log.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Import log from JSON file
    document.getElementById('importBtn').addEventListener('click', function () {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (ev) {
        try {
          const imported = JSON.parse(ev.target.result);
          if (Array.isArray(imported)) {
            commLog = imported;
            saveLog();
            renderTable();
            alert('Log imported successfully.');
          } else {
            alert('Invalid file format. Expected an array of entries.');
          }
        } catch (err) {
          alert('Error parsing the JSON file.');
          console.error(err);
        }
        document.getElementById('fileInput').value = '';
      };
      reader.readAsText(file);
    });

    // Initialize on load and set up paste handler for bulk import
    document.addEventListener('DOMContentLoaded', function () {
      // Load existing data and person list
      loadLog();
      loadPersons();

      // Set up change handler for person dropdown to show/hide new person input
      const personSelect = document.getElementById('person');
      const newPersonContainer = document.getElementById('newPersonContainer');
      const newPersonInput = document.getElementById('newPerson');
      if (personSelect) {
        personSelect.addEventListener('change', function () {
          if (this.value === '__other__') {
            newPersonContainer.style.display = '';
            newPersonInput.required = true;
          } else {
            newPersonContainer.style.display = 'none';
            newPersonInput.required = false;
          }
        });
      }

      // Set up paste handler for bulk import if pasteArea exists
      const pasteArea = document.getElementById('pasteArea');
      if (pasteArea) {
        pasteArea.addEventListener('paste', function (e) {
          e.preventDefault();
          // Try to get HTML and plain text from clipboard
          const clipboardData = e.clipboardData || window.clipboardData;
          const htmlData = clipboardData.getData('text/html') || '';
          const textData = clipboardData.getData('text/plain') || '';
          // Display the pasted content in the area, preserving table formatting if HTML is available
          if (htmlData) {
            pasteArea.innerHTML = htmlData;
          } else {
            pasteArea.textContent = textData;
          }
          // Parse the plain text (tab-separated) into log entries
          if (textData) {
            const rows = textData.trim().split(/\r?\n/);
            let startIdx = 0;
            if (rows.length) {
              const firstCols = rows[0].split(/\t/).map(col => col.trim().toLowerCase());
              // If the first row appears to be a header (starts with "date"), skip it
              if (firstCols[0] === 'date') {
                startIdx = 1;
              }
            }
            for (let i = startIdx; i < rows.length; i++) {
              const cols = rows[i].split(/\t/);
              // Only create an entry if at least six non-empty values exist
              if (cols.filter(val => val.trim() !== '').length >= 6) {
                const [date, person, category, reference, description, nextSteps] = cols;
                const entry = {
                  date: (date || '').trim(),
                  person: (person || '').trim(),
                  category: (category || '').trim(),
                  reference: (reference || '').trim(),
                  description: (description || '').trim(),
                  nextSteps: (nextSteps || '').trim(),
                };
                commLog.push(entry);
              }
            }
            saveLog();
            renderTable();
          }
        });
      }
    });
  </script>
</body>
</html>
