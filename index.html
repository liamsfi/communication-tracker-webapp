<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Communication Tracker WebApp</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      line-height: 1.5;
    }
    h1 {
      color: #2f5496;
    }
    form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }
    label {
      font-weight: bold;
    }
    input, select, textarea {
      width: 100%;
      padding: 6px;
      box-sizing: border-box;
    }
    textarea {
      resize: vertical;
      height: 60px;
    }

    /* Style for contenteditable description input */
    .description-input {
      border: 1px solid #ccc;
      padding: 6px;
      min-height: 60px;
      width: 100%;
      box-sizing: border-box;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: #d9e1f2;
    }
    tr:nth-child(even) {
      /* Stripe table rows for better readability */
      background-color: #f7f7f7;
    }
    /* Styling for the interactive grouped UI */
    .latest-row {
      background-color: #eaf2fb;
      cursor: pointer;
    }
    .details-row {
      background-color: #f7f9fc;
    }
    .toggle-icon {
      cursor: pointer;
      margin-right: 6px;
    }
    .nested-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    .nested-table th, .nested-table td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    .nested-table th {
      background-color: #f0f5ff;
    }
    .button-row {
      margin-top: 10px;
    }
    button {
      padding: 8px 14px;
      margin-right: 10px;
      border: none;
      background-color: #2f5496;
      color: white;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #274778;
    }

  </style>
</head>
<body>
  <h1>Communication Tracker</h1>
  <p>
    This lightweight web app allows you to maintain a structured log of your
    communication updates. Use the form below to add new entries. Your data is
    saved in your browser's local storage so it persists across sessions on the
    same computer.
  </p>

  <form id="entryForm">
    <!-- Hidden date field populated automatically -->
    <input type="hidden" id="date" />
    <div>
      <label for="user">User</label>
      <!-- Dropdown for selecting a user -->
      <select id="user" required></select>
    </div>
    <div>
      <label for="category">Category</label>
      <select id="category" required>
        <option value="RFQ">RFQ</option>
        <option value="Quote">Quote</option>
        <option value="PO">PO</option>
        <option value="ETA">ETA</option>
        <option value="Meeting">Meeting</option>
        <option value="Claim">Claim</option>
        <option value="Payment">Payment</option>
        <option value="Other">Other</option>
      </select>
    </div>
    <div>
      <label for="description">Description / Update</label>
      <!-- Use a contenteditable div so users can paste tables and keep formatting -->
      <div id="description" class="description-input" contenteditable="true"></div>
    </div>
    <div class="button-row">
      <button type="submit">Add Entry</button>
    </div>
  </form>


  <table id="logTable">
    <thead>
      <tr>
        <th>Date</th>
        <th>User</th>
        <th>Category</th>
        <th>Description / Update</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- User management section for adding new users -->
  <h2>User Management</h2>
  <p>Use this section to add new user initials to the list without creating an entry.</p>
  <button type="button" id="showAddUserBtn">Add New User</button>
  <div id="addUserSection" style="display: none; margin-top: 10px;">
    <label for="newUser">User Initials</label>
    <input type="text" id="newUser" placeholder="e.g., LG" />
    <button type="button" id="addUserBtn">Add</button>
  </div>

  <script>
    // Initialize or load existing log from localStorage
    let commLog = [];

    // Manage list of users for the user dropdown
    let users = [];
    function loadUsers() {
      // Prefer 'users' key but fall back to 'persons' for backward compatibility
      let data = localStorage.getItem('users');
      if (!data) {
        data = localStorage.getItem('persons');
      }
      if (data) {
        try {
          users = JSON.parse(data);
        } catch (e) {
          users = [];
        }
      }
      // If no users stored or list is empty, use default initials
      if (!Array.isArray(users) || users.length === 0) {
        users = ['LG', 'MJ', 'TW', 'JY'];
      }
      renderUserOptions();
    }
    function saveUsers() {
      localStorage.setItem('users', JSON.stringify(users));
    }
    function renderUserOptions() {
      const select = document.getElementById('user');
      if (!select) return;
      const current = select.value;
      select.innerHTML = '';
      users.forEach(u => {
        const opt = document.createElement('option');
        opt.value = u;
        opt.textContent = u;
        select.appendChild(opt);
      });
      // Restore selection if it still exists in the list
      if (current && users.includes(current)) {
        select.value = current;
      } else {
        select.value = '';
      }
    }

    function loadLog() {
      const data = localStorage.getItem('comm_log');
      if (data) {
        try {
          commLog = JSON.parse(data);
        } catch (e) {
          console.error('Failed to parse log from localStorage', e);
          commLog = [];
        }
      } else {
        commLog = [];
      }
      // Ensure each entry has an id and responses array for nested replies
      commLog.forEach(entry => ensureEntryShape(entry));
      renderTable();
    }

    function saveLog() {
      localStorage.setItem('comm_log', JSON.stringify(commLog));
    }

    /**
     * Recursively ensure that an entry (and all nested responses) has an id and a responses array.
     * This is important when loading old logs from localStorage that may not include these fields.
     */
    function ensureEntryShape(entry) {
      // Assign a unique id if missing. Fall back to any existing reference as id for backwards compatibility.
      if (!entry.id) {
        entry.id = (entry.reference || Date.now().toString()) + Math.random().toString(36).substr(2, 9);
      }
      // Normalize person/user field (older logs may store 'user' instead of 'person')
      if (!entry.person && entry.user) {
        entry.person = entry.user;
      }
      // Ensure responses array exists
      if (!Array.isArray(entry.responses)) {
        entry.responses = [];
      }
      // Recursively ensure shape on nested responses
      entry.responses.forEach(child => ensureEntryShape(child));
    }

    function renderTable() {
      const tbody = document.querySelector('#logTable tbody');
      tbody.innerHTML = '';
      // Sort top-level entries by date descending
      const sortedEntries = commLog.slice().sort((a, b) => new Date(b.date) - new Date(a.date));
      sortedEntries.forEach(entry => {
        renderEntry(entry, 0, tbody);
      });
    }

    /**
     * Recursively render an entry and its nested responses into the table body.
     * @param {Object} entry - The entry to render
     * @param {number} level - Nesting level (0 for top-level entries)
     * @param {HTMLElement} tbody - Table body element
     */
    function renderEntry(entry, level, tbody) {
      // Ensure the entry has a responses array
      if (!entry.responses) entry.responses = [];
      // Create a row for this entry
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding-left: ${level * 20}px">${entry.date}</td>
        <td>${entry.person}</td>
        <td>${entry.category}</td>
        <td>${entry.description}<br>
          <button data-action="reply" data-id="${entry.id}">Reply</button>
        </td>
      `;
      tbody.appendChild(tr);
      // Create a hidden row for the reply form
      const replyRow = document.createElement('tr');
      replyRow.style.display = 'none';
      replyRow.dataset.parentId = entry.id;
      replyRow.innerHTML = `
        <td colspan="4" style="padding-left: ${level * 20 + 20}px">
          <div contenteditable="true" class="reply-input" style="border:1px solid #ccc; padding:6px; min-height:40px;"></div>
          <button data-action="save-reply" data-parent-id="${entry.id}">Save</button>
          <button data-action="cancel-reply" data-parent-id="${entry.id}">Cancel</button>
        </td>
      `;
      tbody.appendChild(replyRow);
      // Recursively render nested responses with increased indentation
      entry.responses.forEach(child => {
        renderEntry(child, level + 1, tbody);
      });
    }

    /**
     * Recursively find an entry or response by its id within a list of entries.
     * @param {Array} entries - List of entries to search
     * @param {string} id - The id of the entry to find
     * @returns {Object|null} The matching entry or null if not found
     */
    function findEntryById(entries, id) {
      for (const entry of entries) {
        if (entry.id === id) {
          return entry;
        }
        if (entry.responses && entry.responses.length) {
          const found = findEntryById(entry.responses, id);
          if (found) return found;
        }
      }
      return null;
    }

    document.getElementById('entryForm').addEventListener('submit', function (e) {
      e.preventDefault();
      // Determine the selected user from the dropdown
      const userSelect = document.getElementById('user');
      let userVal = userSelect.value;
      const descDivVal = document.getElementById('description').innerText || document.getElementById('description').textContent;
      if (!descDivVal.trim()) {
        alert('Please enter a description/update.');
        return;
      }
      const entry = {
        // Use the hidden date input which is auto-populated on load and after reset
        date: document.getElementById('date').value,
        person: userVal,
        category: document.getElementById('category').value,
        // Unique identifier for this entry
        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
        // Capture HTML from the contenteditable description field
        description: document.getElementById('description').innerHTML.trim(),
        // Array to hold nested responses
        responses: []
      };
      commLog.push(entry);
      saveLog();
      renderTable();
      this.reset();
      // After resetting the form, set the date field to today again
      const dateAfterReset = document.getElementById('date');
      if (dateAfterReset) {
        dateAfterReset.value = new Date().toISOString().split('T')[0];
      }
      // Clear the description contenteditable field
      const descDiv = document.getElementById('description');
      if (descDiv) {
        descDiv.innerHTML = '';
      }
      // Re-render user options in case a new user was added elsewhere
      renderUserOptions();
    });


    // Initialize on load and set up paste handler for bulk import
    document.addEventListener('DOMContentLoaded', function () {
      // Load existing data and user list
      loadLog();
      loadUsers();

      // Automatically set the date field to today's date on page load
      const dateInput = document.getElementById('date');
      if (dateInput) {
        const today = new Date().toISOString().split('T')[0];
        dateInput.value = today;
      }

      // Set up user management UI
      const showAddUserBtn = document.getElementById('showAddUserBtn');
      const addUserSection = document.getElementById('addUserSection');
      const addUserBtn = document.getElementById('addUserBtn');
      const newUserInput = document.getElementById('newUser');

      if (showAddUserBtn) {
        showAddUserBtn.addEventListener('click', function () {
          // Toggle visibility of the add user section when button is clicked
          if (addUserSection.style.display === 'none' || addUserSection.style.display === '') {
            addUserSection.style.display = '';
            if (newUserInput) newUserInput.focus();
          } else {
            addUserSection.style.display = 'none';
          }
        });
      }
      if (addUserBtn) {
        addUserBtn.addEventListener('click', function () {
          const val = newUserInput ? newUserInput.value.trim() : '';
          if (val) {
            if (!users.includes(val)) {
              users.push(val);
              saveUsers();
            }
            if (newUserInput) newUserInput.value = '';
            if (addUserSection) addUserSection.style.display = 'none';
            renderUserOptions();
          }
        });
      }

      // Set up paste handler for the description box to preserve formatting when pasting tables
      const descriptionDiv = document.getElementById('description');
      if (descriptionDiv) {
        descriptionDiv.addEventListener('paste', function (e) {
          e.preventDefault();
          // Try to get HTML and plain text from clipboard
          const clipboardData = e.clipboardData || window.clipboardData;
          const htmlData = clipboardData.getData('text/html') || '';
          const textData = clipboardData.getData('text/plain') || '';
          // Display the pasted content, preserving table formatting if HTML is available
          if (htmlData) {
            descriptionDiv.innerHTML = htmlData;
          } else {
            descriptionDiv.textContent = textData;
          }
        });
      }

      // Set up reply handling on the log table. Use event delegation to handle
      // Reply, Save and Cancel actions for both entries and nested responses.
      const tbodyEl = document.querySelector('#logTable tbody');
      if (tbodyEl) {
        tbodyEl.addEventListener('click', function (event) {
          const action = event.target.dataset.action;
          if (!action) return;
          // Reply button toggles the reply row for the associated entry
          if (action === 'reply') {
            const id = event.target.dataset.id;
            const replyRow = this.querySelector(`tr[data-parent-id='${id}']`);
            if (replyRow) {
              // Toggle visibility
              replyRow.style.display = replyRow.style.display === 'none' ? '' : 'none';
              // Focus the input when showing
              if (replyRow.style.display === '') {
                const input = replyRow.querySelector('.reply-input');
                if (input) input.focus();
              } else {
                // Clear the input when hiding
                const input = replyRow.querySelector('.reply-input');
                if (input) input.innerHTML = '';
              }
            }
          } else if (action === 'save-reply') {
            const parentId = event.target.dataset.parentId;
            const replyRow = this.querySelector(`tr[data-parent-id='${parentId}']`);
            if (!replyRow) return;
            const input = replyRow.querySelector('.reply-input');
            const content = input ? input.innerHTML.trim() : '';
            if (!content) {
              alert('Please enter a response.');
              return;
            }
            const userVal = document.getElementById('user').value;
            const parentEntry = findEntryById(commLog, parentId);
            let category = parentEntry ? parentEntry.category : 'Response';
            const newResponse = {
              id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
              date: new Date().toISOString().split('T')[0],
              person: userVal,
              category: category,
              description: content,
              responses: []
            };
            if (parentEntry) {
              if (!Array.isArray(parentEntry.responses)) parentEntry.responses = [];
              parentEntry.responses.push(newResponse);
            }
            saveLog();
            renderTable();
          } else if (action === 'cancel-reply') {
            const parentId = event.target.dataset.parentId;
            const replyRow = this.querySelector(`tr[data-parent-id='${parentId}']`);
            if (!replyRow) return;
            replyRow.style.display = 'none';
            const input = replyRow.querySelector('.reply-input');
            if (input) input.innerHTML = '';
          }
        });
      }
    });
  </script>
</body>
</html>
